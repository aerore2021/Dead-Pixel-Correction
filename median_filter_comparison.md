# DPC Stage2 中值滤波器实现方案技术文档

## 概述

本文档详细介绍了`Filter_Function_dpc_stage2_median.v`模块中3x3和5x5中值滤波器的实现方案，包括算法原理、硬件架构、性能分析和设计权衡。

## 目录

1. [背景与需求](#背景与需求)
2. [3x3中值滤波实现](#3x3中值滤波实现)
3. [5x5中值滤波实现](#5x5中值滤波实现)
4. [性能对比分析](#性能对比分析)
5. [设计权衡](#设计权衡)
6. [验证方法](#验证方法)

---

## 背景与需求

### 应用场景
- **用途**: 图像传感器坏点校正(DPC - Defect Pixel Correction)
- **功能**: 当检测到中心像素为坏点时，使用邻域中值替换
- **要求**: 
  - 低延迟（适合实时图像处理）
  - 资源消耗合理
  - 支持边界像素处理
  - 优先选择非坏点进行中值计算

### 技术约束
- **位宽**: 支持可配置像素位宽（典型14位）
- **接口**: AXI-Stream兼容
- **时钟**: 单时钟域设计
- **流水线**: 支持连续像素流处理

---

## 3x3中值滤波实现

### 算法原理

#### 窗口结构
```
+-----+-----+-----+
| w11 | w12 | w13 |
+-----+-----+-----+
| w21 | w22 | w23 |
+-----+-----+-----+
| w31 | w32 | w33 |
+-----+-----+-----+
```

- **邻域数量**: 8个（排除中心w22）
- **中值选择**: 第4和第5小的元素之间选择
- **坏点处理**: 优先选择非坏点元素

#### 边界处理
对于3x3窗口，采用简单的边界复制：
- **边界像素**: 复制最近的有效像素
- **角点**: 复制对角线最近像素

### 硬件实现架构

#### 排序网络设计
采用**比较交换网络**（Compare-Swap Network）实现8元素排序：

```verilog
// 第一层：4个并行比较器
sA0_0 = min(p0,p1); sA0_1 = max(p0,p1);
sA0_2 = min(p2,p3); sA0_3 = max(p2,p3);
sA0_4 = min(p4,p5); sA0_5 = max(p4,p5);
sA0_6 = min(p6,p7); sA0_7 = max(p6,p7);

// 第二层：合并排序
// ... (详细网络结构)

// 第三层：最终排序
final3 = 第4小元素 (下中值)
final4 = 第5小元素 (上中值)
```

#### 流水线结构
```
阶段1: 输入寄存 → 阶段2: 排序网络A → 阶段3: 排序网络B → 阶段4: 中值选择 → 输出
延迟: 4个时钟周期
```

### 资源消耗
- **比较器数量**: ~28个
- **寄存器**: ~200个（8位宽时）
- **组合逻辑深度**: 中等（3-4级逻辑）

---

## 5x5中值滤波实现

### 算法原理

#### 窗口结构
```
+-----+-----+-----+-----+-----+
| w11 | w12 | w13 | w14 | w15 |
+-----+-----+-----+-----+-----+
| w21 | w22 | w23 | w24 | w25 |
+-----+-----+-----+-----+-----+
| w31 | w32 | w33 | w34 | w35 |
+-----+-----+-----+-----+-----+
| w41 | w42 | w43 | w44 | w45 |
+-----+-----+-----+-----+-----+
| w51 | w52 | w53 | w54 | w55 |
+-----+-----+-----+-----+-----+
```

- **邻域数量**: 24个（排除中心w33）
- **中值选择**: 第12和第13小的元素之间选择
- **坏点处理**: 优先选择非坏点元素

#### 复杂边界处理
5x5窗口需要处理更复杂的边界情况：

##### 边界标志
```verilog
input filter_is_first_row,        // 第一行
input filter_is_last_row,         // 最后一行  
input filter_is_first_column,     // 第一列
input filter_is_last_column,      // 最后一列
input filre_is_2rd_row,           // 第二行
input filter_is_last_2rd,         // 倒数第二行
input filter_is_2ed_column,       // 第二列
input filter_is_last_2rd_column   // 倒数第二列
```

##### Padding逻辑示例
```verilog
// e11位置的padding逻辑
wire [WIDTH-1:0] e11 = 
  is_first_row ? 
    (is_first_column ? w33 : 
     (is_2nd_column ? w23 : w21)) : 
  (is_2nd_row ? 
    (is_first_column ? w23 : 
     (is_2nd_column ? w22 : w21)) :
    (is_first_column ? w13 : 
     (is_2nd_column ? w12 : w11)));
```

### 硬件实现架构

考虑到24元素排序的复杂性，采用**分治计数法**：

#### 两段计数中值算法
```verilog
// 阶段1: 计算每个候选与前12个邻域的比较计数
for (ia = 0; ia < 24; ia++) begin
  cnt_half1[ia] = 0;
  for (jb = 0; jb < 12; jb++) begin
    if (neighbors[jb] <= neighbors[ia]) 
      cnt_half1[ia]++;
  end
end

// 阶段2: 计算每个候选与后12个邻域的比较计数  
for (ia = 0; ia < 24; ia++) begin
  cnt_half2[ia] = 0;
  for (jb = 12; jb < 24; jb++) begin
    if (neighbors[jb] <= neighbors[ia])
      cnt_half2[ia]++;
  end
end

// 阶段3: 合并计数，选择第12/13小元素
total_cnt[ia] = cnt_half1[ia] + cnt_half2[ia];
// 寻找 total_cnt == 12 或 13 的元素
```

#### 流水线结构
```
阶段1: 输入寄存 → 阶段2: Padding处理 → 阶段3: 邻域寄存 → 
阶段4: 第一段计数 → 阶段5: 第二段计数 → 阶段6: 中值选择 → 输出
延迟: 6个时钟周期
```

### 资源消耗
- **比较器数量**: 24×12×2 = 576个
- **寄存器**: ~800个（14位宽时）
- **组合逻辑深度**: 较深（5-6级逻辑）

---

## 性能对比分析

| 特性 | 3x3实现 | 5x5实现 | 备注 |
|------|---------|---------|------|
| **邻域数量** | 8 | 24 | 5x5提供更好的噪声抑制 |
| **延迟** | 4时钟周期 | 6时钟周期 | 5x5延迟增加50% |
| **比较器数量** | ~28 | ~576 | 5x5资源消耗显著增加 |
| **寄存器数量** | ~200 | ~800 | 5x5需要更多存储 |
| **边界处理** | 简单 | 复杂 | 5x5需要8种边界条件 |
| **中值质量** | 中等 | 高 | 更大窗口提供更稳定结果 |

### 时序分析

#### 3x3关键路径
```
输入 → 比较器网络(3级) → 中值选择 → 输出寄存器
总延迟: ~4ns (100MHz时钟)
```

#### 5x5关键路径  
```
输入 → Padding逻辑 → 计数器阵列 → 中值判断 → 输出寄存器
总延迟: ~8ns (125MHz时钟)
```

---

## 设计权衡

### 方案选择考虑因素

#### 选择3x3的场景
- **实时性要求极高**: 需要最低延迟
- **资源受限**: FPGA资源紧张
- **简单坏点**: 坏点分布稀疏且孤立
- **边界像素较少**: 图像边缘不重要

#### 选择5x5的场景
- **图像质量优先**: 需要更好的噪声抑制
- **复杂坏点**: 坏点可能聚集出现
- **边界质量重要**: 图像边缘需要精确处理
- **资源充足**: 有足够的FPGA资源

### 优化策略

#### 针对3x3的优化
1. **流水线优化**: 减少关键路径深度
2. **资源共享**: 复用比较器逻辑
3. **时钟门控**: 降低功耗

#### 针对5x5的优化
1. **分级计数**: 避免全并行排序
2. **寄存器分段**: 平衡延迟和资源
3. **边界预计算**: 减少实时计算复杂度

---

## 验证方法

### Verilog仿真验证
- **单元测试**: 针对各种边界条件
- **随机测试**: 大量随机数据验证
- **边界测试**: 专门测试图像边缘情况

### Python参考模型
```python
def median_5x5_filter(image, bad_map):
    """5x5中值滤波参考实现"""
    # 实现padding逻辑
    padded_image, padded_bad = replicate_padding(image, bad_map)
    
    # 对每个像素进行滤波
    for row in range(height):
        for col in range(width):
            if bad_map[row, col]:  # 仅对坏点进行替换
                # 提取5x5邻域（排除中心）
                neighbors = extract_neighbors_24(padded_image, row, col)
                # 计算中值
                filtered_image[row, col] = compute_median(neighbors)
            else:
                filtered_image[row, col] = image[row, col]
    
    return filtered_image
```

### 验证覆盖率
- **功能覆盖**: 所有边界条件组合
- **代码覆盖**: 所有代码路径执行
- **性能验证**: 时序满足要求
- **资源验证**: 综合后资源使用

---

## 结论与建议

### 总结
1. **3x3实现**适合对延迟敏感、资源受限的应用
2. **5x5实现**适合对图像质量要求较高的应用
3. 两种方案都经过充分验证，可根据具体需求选择

### 未来改进方向
1. **自适应选择**: 根据图像内容动态选择窗口大小
2. **混合方案**: 边界使用3x3，内部使用5x5
3. **近似算法**: 使用近似中值算法降低资源消耗
4. **并行处理**: 支持多像素并行处理提升吞吐量

### 使用建议
- **原型阶段**: 建议先使用3x3验证算法效果
- **产品化**: 根据实际图像质量要求选择合适方案
- **资源规划**: 为5x5方案预留足够的FPGA资源
- **时序设计**: 确保满足目标时钟频率要求

---

*文档版本: v1.0*  
*最后更新: 2025年9月19日*  
*作者: AI Assistant*